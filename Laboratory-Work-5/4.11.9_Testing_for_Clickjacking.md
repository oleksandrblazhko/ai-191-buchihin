
# Тестування на Клікджекінг

# Підсумок

Клікджекінг, підмножина відновлення інтерфейсу користувача, є зловмисною технікою, за допомогою якої веб-користувача обманом змушують взаємодіяти (у більшості випадків шляхом клацання) з чимось іншим, ніж те, з чим користувач вважає, що він взаємодіє. Цей тип атаки, окремо або в поєднанні з іншими атаками, потенційно може надсилати несанкціоновані команди або розкривати конфіденційну інформацію, коли жертва взаємодіє з, здавалося б, нешкідливими веб-сторінками. Термін клікджекінг був введений Джеремією Гроссманом і Робертом Гансеном у 2008 році.

Атака клікджекінг використовує, здавалося б, нешкідливі функції HTML і JavaScript, щоб змусити жертву виконати небажані дії, наприклад натиснути невидиму кнопку, яка виконує ненавмисну операцію. Це проблема безпеки на стороні клієнта, яка впливає на різноманітні браузери та платформи.

Щоб здійснити цю атаку, зловмисник створює на перший погляд нешкідливу веб-сторінку, яка завантажує цільову програму за допомогою вбудованого фрейму (прихованого кодом CSS). Як тільки це буде зроблено, зловмисник може спонукати жертву взаємодіяти з веб-сторінкою іншими способами (через, наприклад, соціальну інженерію). Як і для інших атак, загальною передумовою є те, що жертва автентифікована на цільовому веб-сайті зловмисника.

Жертва переглядає веб-сторінку зловмисника з наміром взаємодіяти з видимим інтерфейсом користувача, але ненавмисно виконує дії на прихованій сторінці. Використовуючи приховану сторінку, зловмисник може ввести в оману користувачів, змусивши їх виконати дії, які вони ніколи не збиралися виконувати, шляхом розміщення прихованих елементів на веб-сторінці.

Потужність цього методу полягає в тому, що дії, які виконує жертва, походять із прихованої, але автентичної цільової веб-сторінки. Отже, деякі засоби захисту від CSRF, застосовані розробниками для захисту веб-сторінки від атак CSRF, можуть бути обійдені.

# Цілі тесту

 - Зрозумійте заходи безпеки.
 - Оцініть, наскільки суворими є заходи безпеки та чи можна їх обійти.

# Як тестувати

Як згадувалося вище, цей тип атаки часто призначений для того, щоб дозволити зловмиснику спонукати користувачів до дій на цільовому сайті, навіть якщо використовуються анти-CSRF-токени. Необхідно провести тестування, щоб визначити, чи сторінки веб-сайту вразливі до атак клікджекінгів.

Тестувальники можуть перевірити, чи можна завантажити цільову сторінку у вбудованому фреймі, створивши просту веб-сторінку, яка містить фрейм із цільовою веб-сторінкою.

Якщо сторінку `http://www.target.site` успішно завантажено у фрейм, це означає, що сайт уразливий і не має захисту від атак клікджекінгів.

## Обхід захисту від Clickjacking
Якщо сторінка `http://www.target.site` не відображається у вбудованому фреймі, сайт, ймовірно, має певну форму захисту від клікджекінгу. Важливо зауважити, що це не гарантія того, що сторінка повністю захищена від клікджекінгу.

Методи захисту веб-сторінки від клікджекінгу можна розділити на кілька основних механізмів. У деяких випадках можна обійти ці методи, застосувавши певні обхідні шляхи. Додаткові ресурси OWASP щодо захисту від клікджекінгу див. у брошурі OWASP Clickjacking Defense Cheat Sheet.

### Захист на стороні клієнта: руйнування кадрів
Найпоширеніший метод на стороні клієнта, який був розроблений для захисту веб-сторінки від клікджекінгів, називається Frame Busting і складається зі скрипту на кожній сторінці, який не слід обрамляти. Мета цього методу — запобігти функціонуванню сайту, коли він завантажується у фреймі.

Структура коду блокування кадрів зазвичай складається з «умовного оператора» та оператора «зустрічної дії». Для цього типу захисту існують деякі способи обходу, які підпадають під назву «переборка рами бюста». Деякі з цих методів стосуються окремих браузерів, тоді як інші працюють у різних браузерах.

#### Мобільна версія сайту
Мобільні версії веб-сайту зазвичай менші та швидші, ніж настільні, і вони мають бути менш складними, ніж основна програма. Мобільні варіанти часто мають менший захист, оскільки існує неправильне припущення, що зловмисник не може атакувати програму за допомогою смартфона. Це в корені неправильно, тому що зловмисник може підробити справжнє походження, надане веб-браузером, таким чином, немобільна жертва зможе відвідати програму, створену для мобільних користувачів. З цього припущення випливає, що в деяких випадках немає необхідності використовувати методи для уникнення блокування кадрів, коли існують незахищені альтернативи, які дозволяють використовувати однакові вектори атаки.

#### Подвійне обрамлення
Деякі методи блокування фрейму намагаються зламати фрейм, присвоюючи значення атрибуту parent.location у операторі «зустрічної дії».

Такими діями є, наприклад:
 - `self.parent.location = document.location`
 - `parent.location.href = self.location`
 - `parent.location = self.location`

Цей метод працює добре, доки цільова сторінка не буде обрамлена однією сторінкою. Однак, якщо зловмисник вкладає цільову веб-сторінку в один фрейм, який вкладено в інший (подвійний фрейм), то спроба отримати доступ до parent.location стає порушенням безпеки в усіх популярних браузерах через політику навігації кадрів-нащадків. Це порушення безпеки вимикає навігацію протидії.

Код блокування кадрів цільового сайту (example.org):
```
if(top.location!=self.location) {
     parent.location = self.location;
}
```
Верхній кадр зловмисника (fictitious2.html): `<iframe src="fictitious.html">`
Вигаданий підфрейм зловмисника (ficctiveous.html): `<iframe src="http://example.org">`

#### Вимкнення JavaScript
Оскільки цей тип захисту на стороні клієнта покладається на код блокування кадрів JavaScript, якщо жертва вимкнула JavaScript або якщо зловмисник може вимкнути код JavaScript, веб-сторінка не матиме жодного механізму захисту від клікджекінгу.

Є три методи дезактивації, які можна використовувати з фреймами:
 - Обмежені фрейми в Internet Explorer: починаючи з Internet Explorer 6, фрейм може мати атрибут «безпека», який, якщо для нього встановлено значення «restricted», гарантує, що код JavaScript, елементи керування ActiveX і переспрямування на інші сайти не працювати в кадрі.

Приклад:
`<iframe src="http://example.org" security="restricted"></iframe>`
 - Атрибут пісочниці: у HTML5 з’явився новий атрибут під назвою «пісочниця». Він надає набір обмежень щодо вмісту, завантаженого в iframe. На даний момент цей атрибут сумісний лише з Chrome і Safari.

Приклад:
`<iframe src="http://example.org" sandbox></iframe>`
 - Режим дизайну: Пол Стоун продемонстрував проблему безпеки щодо «designMode», який можна ввімкнути на сторінці фрейму (через document.designMode), вимикаючи JavaScript у верхній частині та підфреймі. Режим дизайну наразі реалізовано у Firefox та IE8.

#### Подія OnBeforeUnload
Подія onBeforeUnload може бути використана для уникнення коду блокування кадрів. Ця подія викликається, коли код блокування кадрів хоче знищити iframe, завантажуючи URL-адресу всієї веб-сторінки, а не лише в iframe. Функція обробки повертає рядок, який пропонується користувачеві підтвердити, чи хоче він залишити сторінку. Коли цей рядок відображається користувачеві, він, швидше за все, скасує навігацію, поразивши спробу цілі перешкодити кадру.

Зловмисник може використати цю атаку, зареєструвавши подію вивантаження на верхній сторінці, використовуючи такий приклад коду:
```
<h1>www.fictive.website</h1>
<script>
     window.onbeforeunload = function() {
         return " Ви бажаєте залишити фіктивний сайт?";
     }
</script>
<iframe src="http://example.org">
```
Попередня техніка вимагає взаємодії з користувачем, але того самого результату можна досягти без запиту користувача. Для цього зловмисник має автоматично скасувати вхідний навігаційний запит у обробнику подій onBeforeUnload, багаторазово надсилаючи (наприклад, кожну мілісекунду) навігаційний запит на веб-сторінку, яка відповідає заголовком «HTTP/1.1 204 No Content».

Оскільки з цією відповіддю браузер нічого не робитиме, результатом цієї операції є очищення конвеєра запитів, що робить спробу вихідного блокування фрейму марною.

Наступний приклад коду:
204 сторінка: `<?php header ("HTTP/1.1 204 No Content"); ?>`
Сторінка зловмисника:
```
<script>
     var prevent_bust = 0;
     window.onbeforeunload = функція() {
         prevent_bust++;
     };
     setInterval(
         function() {
             if (prevent_bust > 0) {
                 prevent_bust -= 2;
                 window.top.location = "http://attacker.site/204.php";
             }
         }, 1);
</script>
<iframe src="http://example.org">
```
#### Фільтр XSS
Починаючи з Google Chrome 4.0 і з IE8 були введені фільтри XSS для захисту користувачів від відображених атак XSS. Нава та Ліндсей помітили, що такі фільтри можна використовувати для дезактивації коду блокування кадрів, видаючи його за шкідливий код.
 - Фільтр IE8 XSS: цей фільтр має видимість усіх параметрів кожного запиту та відповіді, що проходять через веб-браузер, і порівнює їх із набором регулярних виразів, щоб шукати відображені спроби XSS. Коли фільтр визначає можливі атаки XSS; він вимикає всі вбудовані скрипти на сторінці, включаючи скрипти блокування кадрів (те саме можна зробити із зовнішніми скриптами). З цієї причини зловмисник може викликати помилковий результат, вставивши початок скрипту блокування кадрів у параметри запиту.

Приклад: код блокування кадрів цільової веб-сторінки:
```
<script>
     if ( top != self ) top.location=self.location;
</script>
```
Код зловмисника:
`<iframe src="http://example.org/?param=<script>if">`
 - Фільтр Chrome 4.0 XSSAuditor: він має дещо іншу поведінку порівняно з фільтром XSS IE8, фактично за допомогою цього фільтра зловмисник може деактивувати «скрипт», передавши його код у параметрі запиту. Це дає змогу сторінці фрейму спеціально націлюватися на окремий фрагмент, що містить код блокування фрейму, залишаючи всі інші коди недоторканими.

Приклад: код блокування кадрів цільової веб-сторінки:
```
<script>
     if ( top != self ) {
         top.location=self.location;
     }
</script>
```
Код зловмисника:
`<iframe src="http://example.org/?param=if(top+!%3D+self)+%7B+top.location%3Dself.location%3B+%7D">`

#### Перевизначення місцезнаходження
Для деяких браузерів змінна “document.location” є незмінним атрибутом. Однак для деяких версій Internet Explorer і Safari цей атрибут можна перевизначити. Цей факт можна використати для уникнення коду блокування кадрів.
 - Перевизначення розташування в IE7 та IE8: можна перевизначити «розташування», як це показано в наступному прикладі. Визначаючи «location» як змінну, будь-який код, який намагається прочитати або здійснити навігацію за допомогою призначення «top.location», не вдасться через порушення безпеки, тому код блокування кадрів призупиняється.

приклад:
```
<script>
     var location = "xyz";
</script>
<iframe src="http://example.org"></iframe>
```
 - Перевизначення розташування в Safari 4.0.4: щоб перекрити код перекриття кадру за допомогою «top.location», можна прив’язати «location» до функції через defineSetter (через вікно), щоб спроба прочитати або перейти до «top. розташування» не вдасться.

приклад:
```
<script>
     window.defineSetter("location" , function(){});
</script>
<iframe src="http://example.org"></iframe>
```
### Захист на стороні сервера: X-Frame-Options
Корпорація Майкрософт реалізувала альтернативний підхід до коду блокування фреймів на стороні клієнта, який складається із захисту на основі заголовка. Цей новий заголовок «X-FRAME-OPTIONS» надсилається із сервера у відповідях HTTP та використовується для позначення веб-сторінок, які не слід обрамляти. Цей заголовок може приймати значення DENY, SAMEORIGIN, ALLOW-FROM походження або нестандартне ALLOWALL. Рекомендоване значення DENY.

«X-FRAME-OPTIONS» є дуже хорошим рішенням, яке було прийнято основними браузерами, але також для цієї техніки існують деякі обмеження, які в будь-якому випадку можуть призвести до використання вразливості клікджекінгу.

#### Сумісність з браузером
Оскільки «X-FRAME-OPTIONS» було представлено в 2009 році, цей заголовок несумісний зі старим браузером. Таким чином, кожен користувач, який не має оновленого браузера, може стати жертвою атаки клікджекінга.

|      Browser      	|  Lowest version 	|
|:-----------------:	|:---------------:	|
| Internet Explorer 	| 8.0             	|
| Firefox (Gecko)   	| 3.6.9 (1.9.2.9) 	|
| Opera             	| 10.50           	|
| Safari            	| 4.0             	|
| Chrome            	| 4.1.249.1042    	|

#### Проксі
Веб-проксі відомі тим, що додають і видаляють заголовки. У випадку, коли веб-проксі видаляє заголовок «X-FRAME-OPTIONS», сайт втрачає захист фрейму.

#### Мобільна версія сайту
Крім того, у цьому випадку, оскільки параметри X-FRAME-OPTIONS мають бути реалізовані на кожній сторінці веб-сайту, можливо, розробники не захистили мобільну версію веб-сайту.

### Створення доказу концепції
Коли ми виявимо, що сайт, який ми тестуємо, вразливий до атаки клікджекінгу, ми можемо продовжити розробку доказу концепції (PoC), щоб продемонструвати вразливість. Важливо зазначити, що, як згадувалося раніше, ці атаки можна використовувати разом з іншими формами атак (наприклад, CSRF-атаками) і можуть призвести до подолання анти-CSRF-токенів. У зв’язку з цим ми можемо уявити, що, наприклад, веб-сайт example.org дозволяє автентифікованим і авторизованим користувачам здійснювати переказ грошей на інший рахунок.

Припустимо, що для виконання перенесення розробники запланували три кроки. На першому кроці користувач заповнює форму з цільовим рахунком і сумою. На другому кроці, щоразу, коли користувач надсилає форму, відображається сторінка підсумку із запитом підтвердження користувача.

Як бачите, код захищено від атаки CSRF як за допомогою випадкового токена, згенерованого на другому кроці, так і для прийняття лише змінної, переданої через метод POST. У цій ситуації зловмисник може підробити атаку CSRF + Clickjacking, щоб уникнути захисту від CSRF і змусити жертву здійснити грошовий переказ без її згоди.

Цільова сторінка для атаки є другим кроком процедури переказу грошей. Оскільки розробники розмістили елементи керування безпекою лише на останньому кроці, вважаючи, що це достатньо безпечно, зловмисник міг передати параметри рахунку та суми за допомогою методу GET.

Сторінка зловмисника може виглядати простою та нешкідливою веб-сторінкою, але зі значенням непрозорості CSS ми можемо побачити, що приховано під, здавалося б, нешкідливою веб-сторінкою.

За допомогою CSS ми можемо маскувати та відповідним чином розташувати iframe таким чином, щоб відповідати кнопкам. Якщо жертва натисне на кнопку «Натисни і вперед!» форму подано, і переказ завершено.



